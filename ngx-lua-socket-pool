#!/usr/bin/env perl

# Copyright (C) Yichun Zhang (agentzh)
# Copyright (C) Guanlan Dai

use 5.006001;
use strict;
use warnings;

use Getopt::Long qw( GetOptions );

GetOptions("a=s",       \(my $stap_args),
           "h",         \(my $help),
           "p=i",       \(my $pid))
    or die usage();

if ($help) {
    print usage();
    exit;
}

if (!$pid) {
    die "No nginx process pid specified by the -p option\n";
}

if (!defined $stap_args) {
    $stap_args = '';
}

if ($stap_args !~ /\b-D\s*MAXACTION=/) {
    $stap_args .= " -DMAXACTION=100000"
}

if ($stap_args !~ /\b-D\s*MAXMAPENTRIES=/) {
    $stap_args .= " -DMAXMAPENTRIES=5000"
}

if ($stap_args !~ /\b-D\s*MAXBACKTRACE=/) {
    $stap_args .= " -DMAXBACKTRACE=200"
}

if ($stap_args !~ /\b-D\s*MAXSTRINGLEN=2048/) {
    $stap_args .= " -DMAXSTRINGLEN=2048"
}

if ($stap_args !~ /\b-D\s*MAXSKIPPED=1024/) {
    $stap_args .= " -DMAXSKIPPED=1024"
}
my ($probes, $operation);


if ($^O ne 'linux') {
    die "Only linux is supported but I am on $^O.\n";
}

my $exec_file = "/proc/$pid/exe";
if (!-f $exec_file) {
    die "Nginx process $pid is not running or ",
        "you do not have enough permissions.\n";
}

my $exec_path = readlink $exec_file;

my $postamble = <<_EOC_;
_EOC_

my $guide;
$guide = "Hit Ctrl-C to end.";

my $preamble = <<_EOC_;

probe begin
{
    printf("Tracing %d ($exec_path)...\\n$guide\\n", target())
}
_EOC_
chop $preamble;

my $L = qq{\@cast(L, "lua_State", "$exec_path")};
my $pool = qq{\@cast(pool, "ngx_http_lua_socket_pool_t", "$exec_path")};
my $USERDATA_TYPE = 7;
my $sizeof_Udata = qq{&\@cast(0, "Udata", "$exec_path")[1]};

my $stap_src = <<_EOC_;
$preamble
global reused_time
function size_node(table) {
    res = \@cast(table,"Table","$exec_path")->lsizenode
    res = 1 << res
    return res
}

function hash_mod(table, key) {
    size = size_node(table)
    i = key % ((size - 1) | 1)
    return i
}

function queue_len(queue) {
    length = 0
    head = queue
    start = \@cast(queue, "ngx_queue_t", "$exec_path")->prev
    curr = start
    while (curr != head) {
        curr = \@cast(curr, "ngx_queue_t", "$exec_path")->prev
        length = length + 1
    }
    return length
}

function traverse_queue(queue) {
    pool_offset = &\@cast(0, "ngx_http_lua_socket_pool_item_t", "$exec_path")->queue
    length = 0
    head = queue
    start = \@cast(queue, "ngx_queue_t", "$exec_path")->prev
    curr = start
    while (curr != head) {
        pool_item = curr - pool_offset
        reused = \@cast(pool_item, "ngx_http_lua_socket_pool_item_t", "$exec_path")->reused
        reused_time <<< reused
        curr = \@cast(curr, "ngx_queue_t", "$exec_path")->prev
        length = length + 1
    }
    if(length > 0) {
        printf("\\treused times max: %d ", \@max(reused_time))
        printf("min: %d ", \@min(reused_time))
        printf("avg: %d\\n", \@avg(reused_time))
    }
    delete reused_time
}
function print_all_the_pool(table) {
    pool_num = 0
    for(i = 0; i < size_node(table); i++) {
        n = &\@cast(table, "Table", "$exec_path")->node[i]
        i_val = &\@cast(n, "Node", "$exec_path")->i_val
        if (\@cast(i_val, "TValue", "$exec_path")->tt == $USERDATA_TYPE) {
            pool_num++
            pool = &\@cast(n, "Node", "$exec_path")->i_val->value->gc->u
            pool += $sizeof_Udata
            pool_key = &$pool->key
            cache = &$pool->cache
            free = &$pool->free
            conn_num =  $pool->active_connections
            printf("pool \\"%s\\"\\n", text_str(user_string(pool_key)))
            printf("\tout-of-pool connections: %d\\n", conn_num)
            printf("\tin-pool connections: %d\\n", queue_len(cache))
            traverse_queue(cache)
            printf("\tpool capacity: %d\\n\\n", queue_len(cache) + queue_len(free))
        }
    }
    if (pool_num > 0) {
        print("Summary\\n")
        printf("Total Number of Pools:%d\\n", pool_num)
        exit()
    }
}

probe process("$exec_path").function("ngx_http_lua_socket_tcp_send")
{
    L = \@var("L")
    if(L){
        begin = gettimeofday_us()
        key = &\@var("ngx_http_lua_socket_pool_key")
        lg = \@cast(L, "lua_State")->l_G
        registrytv = &\@cast(lg, "global_State")->l_registry
        table = &\@cast(registrytv, "TValue")->value->gc->h
        index = hash_mod(table, key)
        pool_tables = &\@cast(table, "Table")->node[index]->i_val->value->gc->h
        if(pool_tables) {
            print_all_the_pool(pool_tables)
        }
        elapsed = gettimeofday_us() - begin
        printf("%d microseconds elapsed in the probe handler.\\n", elapsed)
    }
}
$postamble
_EOC_

open my $in, "|stap --skip-badvars $stap_args -x $pid -"
    or die "Cannot run stap: $!\n";

print $in $stap_src;

close $in;

sub usage {
    return <<'_EOC_';
Usage:
    ngx-lua-socket-pool [optoins]

Options
    -a <args>           Pass extra arguments to the stap utility.:
    -p <pid>            Specify the nginx worker process pid.

Examples:
     ngx-lua-socket-pool -p 12345
     ngx-lua-socket-pool -p 12345 -a '-DMAXACTION=100000'
_EOC_
}
